<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Net on 鱼吠</title>
    <link>http://fishu.cn/categories/net/</link>
    <description>Recent content in Net on 鱼吠</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Copyright © 2017 Fishu</copyright>
    <lastBuildDate>Sat, 05 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://fishu.cn/categories/net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于 Go 实现I/O多路复用(一)</title>
      <link>http://fishu.cn/blog/%E5%9F%BA%E4%BA%8E-go-%E5%AE%9E%E7%8E%B0i/o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%80/</link>
      <pubDate>Sat, 05 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://fishu.cn/blog/%E5%9F%BA%E4%BA%8E-go-%E5%AE%9E%E7%8E%B0i/o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%80/</guid>
      <description>可能大家对 Nginx 都不陌生，Nginx 因为它高效的事件模块赢得了众多人的赞赏，Nginx 的事件驱动机制（I/O多路复用）在 Linux 平台下是使用 epoll 来实现，简单来说，epoll 不同于轮询，它会把哪个连接发送了怎样的 I/O 事件通知到我们，今天来说的基于 Go 实现的 I/O 多路复用库 yamux ，没有使用系统级别的事件驱动机制（如：epoll、kqueue），这得益于 Go 廉价的 goroutine 开销，yamux 依赖底层可靠的连接（tcp、unix domain sockets），在可靠的连接之上提供了面向流 I/O 多路复用，其核心思想是在发送数据的时候增加头部信息，附加一层协议。 在 yamux 中，一条连接称为 session，一个 session 可以开启多个数据流，数据流称为 stream。今天先来看下它是如何设计的，下次再分析源码。
定义帧结构 每一帧数据都需要包含如下的头部：
 Version(8 bits) Type(8 bits) Flags(16 bits) StreamID(32 bits) Length(32 bits)  一共12个字节，所有的字段都采用大端（big endian）传输。接下来我们解释每个字段的意思。
Version 字段 顾名思义就是用来指定版本的，目的是为了向后兼容，现在我们可以把他设为0。
Type 字段 区分消息类型：
 0x0 Data - 传输数据 0x1 Window Update - 更新发送者的接收窗口大小 0x2 Ping - 测试 RTT。也可以用来做心跳和 keep-alives 0x3 Go Away - 关闭 session  Flag 字段 配合 type 字段提供额外的信息：</description>
    </item>
    
    <item>
      <title>go channels 注意事项</title>
      <link>http://fishu.cn/blog/go-channels-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://fishu.cn/blog/go-channels-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>在 Go 中，channel 分为unbuffered channel和buffered channel 两种，关于如何使用的问题，这里就不做讨论了。主要来记录下注意事项。
unbuffered channel package main func main() { ch := make(chan int) ch &amp;lt;- 1 &amp;lt;-ch // 没有这行代码也会报同样的错误 }  运行这段代码会出现以下报错： fatal error: all goroutines are asleep - deadlock! 这是因为对于unbuffered channel来说，send 和 receive 都是阻塞操作，除非 channel 的发送和接收端都准备好，否则，send 和 receive 任意一方都会都会导致 goroutine 挂起，出现死锁，解决方法如下：
func main() { ch := make(chan int) go func() { ch &amp;lt;- 1 }() // 另起一个 goroutine &amp;lt;-ch }  buffered channel 大家肯定都知道 buffered channel 是非阻塞的 channel，但是大家有没有对 buffered channel 接收到消息的顺序产生疑问呢，顺序是随机的？还是顺序的？是怎样的顺序？</description>
    </item>
    
  </channel>
</rss>